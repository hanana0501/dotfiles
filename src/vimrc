if has('vim_starting')
    set encoding=utf-8
    scriptencoding utf-8
    
    if !has('gui_running') && exists(&termguicolors) && $COLORTERM ==# 'truecolor'
        let &t_8f = "\e[38;2;%lu;%lu;%lum"
        let &t_8b = "\e[48;2;%lu;%lu;%lum"
        set termguicolors
    endif
endif

augroup vimrc
    autocmd!
augroup END

" echomsg startup time {{{

if has('vim_starting') && has('reltime')
    let g:startuptime = reltime()
    autocmd vimrc VimEnter * let g:startuptime = reltime(g:startuptime) | redraw | echomsg 'startuptime: ' . reltimestr(g:startuptime)
endif
" }}}
" define variable {{{
let s:env = {}
let s:env.path = {}
let s:env.path.cache = expand('~/.cache')
let s:env.path.dein = s:env.path.cache . '/dein'
let s:env.dein = {
            \ 'repo' : 'https://github.com/Shougo/dein.vim',
            \ 'path' : s:env.path.dein . '/repos/github.com/Shougo/dein.vim'}
" }}}
" clone dein if needed {{{
if !isdirectory(s:env.dein.path)
    execute '!git clone' s:env.dein.repo s:env.dein.path
endif
" }}}
" dein add {{{

execute 'set runtimepath+=' . s:env.dein.path

if dein#load_state(s:env.path.dein)
    call dein#begin(s:env.path.dein)

    call dein#add('nanotech/jellybeans.vim')

    call dein#add('Shougo/vimproc.vim', { 'timeout' : 1800, 'build' : 'make' })
    call dein#add('tpope/vim-dispatch')
    call dein#add('ctrlpvim/ctrlp.vim')
    call dein#add('FelikZ/ctrlp-py-matcher', { 'depends' : ['ctrlpvim/ctrlp.vim'] })
    call dein#add('fisadev/vim-ctrlp-cmdpalette',  { 'depends' : ['ctrlpvim/ctrlp.vim']})
    call dein#add('tpope/vim-fugitive')
    call dein#add('thinca/vim-qfreplace')
    call dein#add('itchyny/lightline.vim')
    call dein#add('tyru/caw.vim')
    call dein#add('scrooloose/nerdtree')
    call dein#add('ryanoasis/vim-devicons')
    call dein#add('osyo-manga/vim-anzu')
    call dein#add('cohama/vim-insert-linenr')
    call dein#add('glidenote/memolist.vim')
    call dein#add('wakatime/vim-wakatime')
    call dein#add('christoomey/vim-tmux-navigator')
    call dein#add('gregsexton/VimCalc')
    call dein#add('junegunn/vim-easy-align')
    call dein#add('sheerun/vim-polyglot')
    call dein#add('koron/codic-vim')
    call dein#add('osyo-manga/vim-watchdogs', { 'depends': [ 'Shougo/vimproc.vim', 'thinca/vim-quickrun', 'osyo-manga/shabadou.vim']})
    call dein#add('cohama/vim-hier')
    call dein#add('osyo-manga/shabadou.vim', { 'depends': ['thinca/vim-quickrun']})
    call dein#add('thinca/vim-quickrun')
    call dein#add('majutsushi/tagbar')

    " completion
    call dein#add('Valloric/YouCompleteMe', {'build' : 'git submodule update --init --recursive && ./install.py --cs-completer --clang-completer' })
    call dein#add('artur-shaik/vim-javacomplete2', { 'lazy' : 1, 'on_ft' : ['java'] })
    call dein#add('fatih/vim-go',                  { 'lazy' : 1, 'on_ft' : ['go']})
    call dein#add('vim-ruby/vim-ruby',             { 'lazy' : 1, 'on_ft' : ['ruby']})
    call dein#add('SirVer/ultisnips')
    call dein#add('honza/vim-snippets')

   " syntax
    call dein#add('OrangeT/vim-csharp',               { 'lazy' : 1, 'on_ft':  [ 'cs', 'csi', 'csx' ]})
    call dein#add('octol/vim-cpp-enhanced-highlight', { 'lazy' : 1, 'on_ft': ['cpp'] })
    call dein#add('b4winckler/vim-objc',              { 'lazy' : 1, 'on_ft': ['objc'] })
    call dein#add('keith/swift.vim',                  { 'lazy' : 1, 'on_ft': ['swift'] })
    call dein#add('aklt/plantuml-syntax',             { 'lazy' : 1, 'on_ft': ['uml'] })
    call dein#add('vim-scripts/ShaderHighLight')
 
    " other
    call dein#add('hananana/lilycomment.vim',       { 'lazy' : 1, 'on_ft' : ['cs'] })
    call dein#add('vim-scripts/DoxygenToolkit.vim', { 'lazy' : 1, 'on_ft' : ['cpp', 'objcpp', 'objc'] } )
    call dein#add('kana/vim-altr',                  { 'lazy' : 1, 'on_ft' : ['cpp', 'objcpp', 'objc'] })
    call dein#add('elzr/vim-json',                  { 'lazy' : 1, 'on_ft' : ['json']})
    call dein#add('stephpy/vim-yaml',               { 'lazy' : 1, 'on_ft' : [ 'yaml' ] })
    call dein#add('chrisbra/csv.vim',               { 'lazy' : 1, 'on_ft' : [ 'csv' ] })
    call dein#add('vim-scripts/Align',              { 'lazy' : 1, 'on_ft' : [ 'csv' ] })
    call dein#add('iamcco/markdown-preview.vim',    { 'lazy' : 1, 'on_ft' : [ 'markdown' ] })
 
    call dein#end()
    call dein#save_state()
endif

if dein#check_install()
    call dein#install()
endif

" }}}

filetype plugin indent on

syntax enable
colorscheme jellybeans
set background=dark

" basic setting  {{{

" leaderをspaceにする
let g:mapleader = "\<Space>"
let g:maplocalleader = '\'
" tmuxで色を有効にする
set t_Co=256
" airlineを常時表示するよ
set laststatus=2
"キーのリマップ
nnoremap [ %
" 想定される改行コードの指定する
set fileformats=unix,dos,mac
" インデントまわり
set tabstop=4
set shiftwidth=4
set softtabstop=4
set expandtab
set smarttab
set cindent
" /検索でbottomからtopに戻らない
set nowrapscan
" ビープ音いらん
set visualbell t_vb=
"コマンド表示
set showcmd
"バックアップファイルをとらない
set nobackup
" チルダファイル作成を完全無効化
set noundofile
"スワップファイル用のディレクトリを指定する
set noswapfile
" コマンドライン補完をshellと同一にする
set wildmode=list:longest
"クリップボードを連携する
if has('win32') || has('win63') || has('mac')
    set clipboard=unnamed
else
    set clipboard=unamed, unnamedplus
endif

"変更中のファイルでも、保存しないで他のファイルを表示する
set hidden
"インクリメンタルサーチを行う
set incsearch
"検索したらハイライト
set hlsearch
" 大文字小文字を区別しないで検索する
set ignorecase
set smartcase
" escした時日本語入力をやめる
inoremap <ESC> <ESC>:set iminsert=0<CR>
"行番号を表示する
set number
" バックスペースでインデント削除
set backspace=indent,eol,start
"閉括弧が入力された時、対応する括弧を強調する
set showmatch
" マクロ実行中は再描画しない
set lazyredraw
" くそ長い行を値までで略しちゃう
set synmaxcol=300
" 他のエディタなどで変更があった場合チェックする
set autoread
" 他のエディタなどで変更があった場合チェックする
set autowrite
" focusした時に外部から更新があったかチェック
autocmd vimrc WinEnter * checktime
" vimdiffを縦で割る
set diffopt=vertical
" previewを表示する
set completeopt=menuone,preview
" マーカー折りたたみ
set foldmethod=marker
" 補完ウィンドウは10項目まで
set pumheight=10 
" neovimの文字化け対策
set ttimeout
set ttimeoutlen=50
" spellcheck日本語対応
set spell
set spelllang=en,cjk

set helplang=ja,en

set previewheight=4
autocmd vimrc BufEnter ?* call PreviewHeightWorkAround()
function! PreviewHeightWorkAround()
    if &previewwindow
        exec 'set local winheight='.&previewheight
    endif
endfunction

autocmd vimrc BufNewFile,BufRead *.{md,mdwn,mkd,mkdn,mark*} set filetype=markdown

" grep
if executable('rg')
    set grepprg=rg\ --vimgrep\ --no-heading\ --smart-case
    set grepformat=%f:%l:%c:%m,%f:%l:%m
endif

autocmd vimrc QuickFixCmdPost make,grepadd,grep,vimgrep if len(getqflist()) != 0 | copen | endif
"}}}
" keymaps {{{

"矢印キー無効
noremap <Up> <Nop>
noremap <Down> <Nop>
noremap <Left> <Nop>
noremap <Right> <Nop>
" 移動を常にgjに
nnoremap j gj
nnoremap k gk
" 検索結果のハイライトをEsc連打でクリアする
nnoremap <ESC><ESC> :nohlsearch<CR>
"検索結果を画面中央にもってきてstatuslineに位置表示
nmap n <Plug>(anzu-n-with-echo)zz
nmap N <Plug>(anzu-N-with-echo)zz
nmap * <Plug>(anzu-star-with-echo)zz
nmap # <Plug>(anzu-sharp-with-echo)zz
" こっから<Leader>関連いくぜ！
" タブとウィンドウ分割"
nnoremap <Leader>s :<C-u>sp<CR>
nnoremap <Leader>v :<C-u>vs<CR>
" ヘッダーとの移動
autocmd vimrc FileType cpp,objc,objcpp nmap <Leader>i <Plug>(altr-forward)
" コメントテンプレ展開
autocmd vimrc FileType cs nnoremap <Leader>/ :LilyComment<CR>
autocmd vimrc FileType cpp,objc,objcpp nnoremap <Leader>/ :Dox<CR>
"コメントアウト
nmap <Leader>c <Plug>(caw:zeropos:toggle)
vmap <Leader>c <Plug>(caw:zeropos:toggle)
" レジスタ汚染防止
nnoremap x "_x
nnoremap s "_s
" help
nnoremap <Leader>h :<C-u>vertical belowright help<Space>
" Oで改行
nnoremap O :<C-u>call append(expand('.'), '')<Cr>j
" Yで現在のカーソルから行末までヤンク
nnoremap Y y$

nnoremap <Leader>gg :grep 
nnoremap <Leader>gc :grep <cword>
" }}}

" itchyny/lightline.vim {{{
if dein#tap('lightline.vim')
    let s:on_source = substitute(g:dein#name, '\W', '_', 'g') . '_on_source'
    function! s:{s:on_source}() abort
        let g:lightline = {
                    \ 'colorscheme' : 'jellybeans',
                    \ 'active': {
                    \   'left': [ [ 'mode', 'paste' ],
                    \             [ 'fugitive', 'filename', 'anzu' ] ]
                    \ },
                    \ 'component' : {
                    \   'anzu' : '%{anzu#search_status()}',
                    \ },
                    \ 'component_function': {
                    \   'readonly': 'MyReadOnly',
                    \   'modified': 'MyModified',
                    \   'filename' : 'MyFilename',
                    \   'fugitive': 'MyFugitive',
                    \ },
                    \ 'component_visible_condition': {
                    \   'readonly': '(&filetype!="help"&& &readonly)',
                    \   'modified': '(&filetype!="help"&&(&modified||!&modifiable))',
                    \ },
                    \ 'separator': { 'left': '', 'right': '' },
                    \ 'subseparator': { 'left': '', 'right': '' }
                    \ }
    endfunction

    function! MyModified()
      return &filetype =~# 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
    endfunction

    function! MyReadonly()
      return &filetype !~? 'help\|vimfiler\|gundo' && &readonly ? '⭤' : ''
    endfunction

    function! MyFilename()
      return ('' !=# MyReadonly() ? MyReadonly() . ' ' : '') .
            \ (&filetype ==# 'vimfiler' ? vimfiler#get_status_string() :
            \  &filetype ==# 'unite' ? unite#get_status_string() :
            \  &filetype ==# 'vimshell' ? substitute(b:vimshell.current_dir,expand('~'),'~','') :
            \ '' !=# expand('%:t') ? expand('%:t') : '[No Name]') .
            \ ('' !=# MyModified() ? ' ' . MyModified() : '')
    endfunction

    function! MyFugitive()
       try
        if &filetype !~? 'vimfiler\|gundo' && exists('*fugitive#head')
          let l:_ = fugitive#head()
          return strlen(l:_) ? '⭠ '.l:_ : ''
        endif
      catch
      endtry
      return ''
    endfunction

    call dein#set_hook(g:dein#name, 'hook_add', function('s:' . s:on_source))
endif
" }}}
" ctrlp/ctrlp.vim {{{
if dein#tap('ctrlp.vim')
    let s:on_source = substitute(g:dein#name, '\W', '_', 'g') . '_on_source'
    function! s:{s:on_source}() abort
        nnoremap <Leader>b :CtrlPBuffer<CR>
        nnoremap <Leader>m :CtrlPMRUFiles<CR>
        nnoremap <Leader>q :CtrlPQuickfix<CR>

        let g:ctrlp_map = '<Leader><Leader>'
        let g:ctrlp_show_hidden = 0
        let g:ctrlp_user_command = 'rg %s --files --color=never --glob ""'
        let g:ctrlp_use_caching = 1
        let g:ctrlp_working_path_mode = 0
        let g:ctrlp_match_func = { 'match' : 'pymatcher#PyMatch' }

        let g:ctrlp_prompt_mappings = {
                    \ 'PrtBS()':              ['<bs>'],
                    \ 'PrtDelete()':          ['<del>'],
                    \ 'PrtDeleteWord()':      ['<nop>'],
                    \ 'PrtClear()':           ['<nop>'],
                    \ 'PrtSelectMove("j")':   ['<c-n>'],
                    \ 'PrtSelectMove("k")':   ['<c-p>'],
                    \ 'PrtSelectMove("t")':   ['<nop>'],
                    \ 'PrtSelectMove("b")':   ['<nop>'],
                    \ 'PrtSelectMove("u")':   ['<nop>'],
                    \ 'PrtSelectMove("d")':   ['<nop>'],
                    \ 'PrtHistory(-1)':       ['<nop>'],
                    \ 'PrtHistory(1)':        ['<nop>'],
                    \ 'AcceptSelection("e")': ['<cr>'],
                    \ 'AcceptSelection("h")': ['<c-h>'],
                    \ 'AcceptSelection("t")': ['<nop>'],
                    \ 'AcceptSelection("v")': ['<c-v>'],
                    \ 'ToggleFocus()':        ['<nop>'],
                    \ 'ToggleRegex()':        ['<nop>'],
                    \ 'ToggleByFname()':      ['<c-d>'],
                    \ 'ToggleType(1)':        ['<c-k>'],
                    \ 'ToggleType(-1)':       ['<c-j>'],
                    \ 'PrtExpandDir()':       ['<nop>'],
                    \ 'PrtInsert("c")':       ['<nop>'],
                    \ 'PrtInsert()':          ['<nop>'],
                    \ 'PrtCurStart()':        ['<nop>'],
                    \ 'PrtCurEnd()':          ['<nop>'],
                    \ 'PrtCurLeft()':         ['<nop>'],
                    \ 'PrtCurRight()':        ['<nop>'],
                    \ 'PrtClearCache()':      ['<c-l>'],
                    \ 'PrtDeleteEnt()':       ['<nop>'],
                    \ 'CreateNewFile()':      ['<nop>'],
                    \ 'MarkToOpen()':         ['<nop>'],
                    \ 'OpenMulti()':          ['<nop>'],
                    \ 'PrtExit()':            ['<c-[>'],
                    \ }
    endfunction
    call dein#set_hook(g:dein#name, 'hook_add', function('s:' . s:on_source))
endif
" }}}
" fisadev/vim-ctrlp-cmdpalette {{{
if dein#tap('vim-ctrlp-cmdpalette')
    nnoremap <Leader>p :CtrlPCmdPalette<CR>
endif
" }}}
" scrooloose/nerdtree {{{
if dein#tap('nerdtree')
    let s:on_source = substitute(g:dein#name, '\W', '_', 'g') . '_on_source'
    function! s:{s:on_source}() abort
        nmap <C-e> :NERDTreeToggle<CR>
	 	autocmd vimrc BufEnter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
    endfunction
    call dein#set_hook(g:dein#name, 'hook_add', function('s:' . s:on_source))
endif
" }}}
" lambdalisue/gina.vim {{{
if dein#tap('gina.vim')
    let s:on_source = substitute(g:dein#name, '\W', '_', 'g') . '_on_source'
    function! s:{s:on_source}() abort
        noremap <silent> <Leader>gis :<C-u>Gina status<CR>
        noremap <silent> <Leader>gic :<C-u>Gina commit<CR>
    endfunction
    call dein#set_hook(g:dein#name, 'hook_add', function('s:' . s:on_source))
endif
" }}}
" glidenote/memolist.vim {{{
if dein#tap('memolist.vim')
    let s:on_source = substitute(g:dein#name, '\W', '_', 'g') . '_on_source'
    function! s:{s:on_source}() abort
let g:memolist_path = '$HOME/Dropbox/memolist'
let g:memolist_memo_suffix = 'md'
    endfunction
    call dein#set_hook(g:dein#name, 'hook_add', function('s:' . s:on_source))
endif
" }}}
" ryanoasis/vim-devicons {{{
if dein#tap('vim-devicons')
    let s:on_source = substitute(g:dein#name, '\W', '_', 'g') . '_on_source'
    function! s:{s:on_source}() abort
        " vim-devicons
        let g:webdevicons_conceal_nerdtree_brackets = 1
        let g:WebDevIconsNerdTreeAfterGlyphPadding = '  '
        let g:WebDevIconsUnicodeDecorateFolderNodes = 1
        let g:WebDevIconsNerdTreeGitPluginForceVAlign = 1
        let g:WebDevIconsUnicodeDecorateFolderNodes = 1
        " file-icons
        let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols = {}
        let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols['cs'] = ''
        let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols['swift'] = ''
    endfunction
    call dein#set_hook(g:dein#name, 'hook_add', function('s:' . s:on_source))
endif

" }}}
" terryma/vim-multiple-cursors {{{
if dein#tap('vim-multiple-cursors')
    let s:on_source = substitute(g:dein#name, '\W', '_', 'g') . '_on_source'
    function! s:{s:on_source}() abort
        let g:multi_cursor_use_default_mapping=1
    endfunction
    call dein#set_hook(g:dein#name, 'hook_add', function('s:' . s:on_source))
endif
" }}}
" thinca/vim-quickrun {{{
if dein#tap('vim-quickrun')
    nnoremap <Leader>q :<C-u>QuickRun<CR>
    let g:quickrun_config = get(g:, 'quickrun_config', {})
    let g:quickrun_config['_'] = {
                \ 'runner' : 'vimproc',
                \ 'runner/vimproc/updatetime' : 1,
                \ 'outputter' : 'multi:buffer:quickfix',
                \ 'outputter/buffer/close_on_empty' : 1,
                \ 'outputter/buffer/split' : 'botright',
                \ 'outputter/quickfix/into' : 1,
                \ 'hook/echo/enable' : 1,
                \ 'hook/echo/output_success' : 'SUCCESS  ',
                \ 'hook/echo/output_failure' : 'FAILURE  ',
                \ 'hook/inu/enable' : 1,
                \ 'hook/inu/wait' : 1
                \}
    let g:quickrun_config.cs = { 'type' : 'xbuild' }
    let g:quickrun_config.xbuild = {
                \ 'command' : 'xbuild',
                \ 'exec' : '%c %o',
                \ 'cmdopt' : '/nologo /verbosity:quiet /property:WarningLevel=1', 
                \ 'quickfix/error': '%f\\(%l\\,%c\\)%m', 
                \ 'outputter' : 'quickfix'
                \ }
endif
" }}}
" osyo-manga/vim-watchdogs {{{
if dein#tap('vim-watchdogs')
    let g:watchdogs_check_BufWritePost_enable = 1

    " C# 
    if executable('mcs')
        let g:quickrun_config['cs/watchdogs_checker'] = {
                    \ 'type' : 'watchdogs_checker/mcs'}
        let g:quickrun_config['watchdogs_checker/mcs'] = {
                    \ 'command' : 'mcs',
                    \ 'exec' : '%c %o %s:p',
                    \ 'cmdopt' : '--parse',
                    \ 'quickfix/error': '%f\\(%l\\,%c\\):\ error\ CS%n:\ %m'
                    \ }
    endif
	" Shell script {{{
	if executable('shellcheck')
		let g:quickrun_config['sh/watchdogs_checker'] = {
					\ 'type': 'watchdogs_checker/shellcheck'}
		let g:quickrun_config['watchdogs_checker/shellcheck'] = {
					\ 'command': 'shellcheck',
					\ 'exec': '%c %o %s:p'}
	endif
	"}}}
    call watchdogs#setup(g:quickrun_config)
endif
" }}}
" osyo-manga/shobadou.vim {{{
if dein#tap('shabadou.vim')

endif
" }}}
" majutsushi/tagbar {{{
if dein#tap('tagbar')
    nnoremap <Leader>t :<C-u>TagbarToggle<CR>
endif
" }}}
" Valloric/YouCompleteMe {{{
nnoremap <LocalLeader>r <C-u>:YcmCompleter ReloadSolution<CR>
nnoremap <LocalLeader>t <C-u>:YcmCompleter GetType<CR>

let g:UltiSnipsExpandTrigger='<c-k>'
let g:UltiSnipsJumpForwardTrigger='<c-k>'
let g:UltiSnipsJumpBackwardTrigger='<c-z>'
let g:UltiSnipsEditSplit='vertical'

let g:ycm_min_num_of_chars_for_completion = 3
let g:ycm_min_num_identifier_candidate_chars = 3
let g:ycm_key_invoke_completion = '<C-o>'
let g:ycm_show_diagnostics_ui = 0
let g:ycm_confirm_extra_conf = 0
let g:ycm_key_detailed_diagnostics = ''
let g:ycm_global_ycm_extra_conf = '~/src/github.com/hananana/dotfile/src/global_ycm_extra_conf.py'
let g:ycm_extra_conf_vim_data = ['&filetype', 'expand(expand("<sfile>:p:h"))']
let g:ycm_semantic_triggers = get( g:,'ycm_semantic_triggers', {} )
let g:ycm_semantic_triggers.vim = ['$', '&', 're![\w&$<-][\w:#<>-]*']
let g:ycm_semantic_triggers.objc = [
            \ 're!\@"\.*"\s',
            \ 're!\@\w+\.*\w*\s',
            \ 're!\@\(\w+\.*\w*\)\s',
            \ 're!\@\(\s*',
            \ 're!\@\[.*\]\s',
            \ 're!\@\[\s*',
            \ 're!\@\{.*\}\s',
            \ 're!\@\{\s*',
            \ 're!\@\’.*\’\s',
            \ '#ifdef ',
            \ 're!:\s*',
            \ 're!=\s*',
            \ 're!,\s*', ]
let g:ycm_semantic_triggers.objcpp = [
            \ '->','::',
            \ 're!\@"\.*"\s',
            \ 're!\@\w+\.*\w*\s',
            \ 're!\@\(\w+\.*\w*\)\s',
            \ 're!\@\(\s*',
            \ 're!\@\[.*\]\s',
            \ 're!\@\[\s*',
            \ 're!\@\{.*\}\s',
            \ 're!\@\{\s*',
            \ 're!\@\’.*\’\s',
            \ '#ifdef ',
            \ 're!:\s*',
            \ 're!=\s*',
            \ 're!,\s*', ]
let g:ycm_semantic_triggers.cpp = [
            \ '->','::',
            \ 're!\@"\.*"\s',
            \ 're!\@\w+\.*\w*\s',
            \ 're!\@\(\w+\.*\w*\)\s',
            \ 're!\@\(\s*',
            \ 're!\@\[.*\]\s',
            \ 're!\@\[\s*',
            \ 're!\@\{.*\}\s',
            \ 're!\@\{\s*',
            \ 're!\@\’.*\’\s',
            \ '#ifdef ',
            \ 're!:\s*',
            \ 're!=\s*',
            \ 're!,\s*', ]
let g:ycm_filetype_blacklist = {
            \ 'ruby' : 1
            \ }
" }}}
" artur-shaik/vim-javacomplete2' {{{
if dein#tap('vim-javacomplete2')
    let s:on_source = substitute(g:dein#name, '\W', '_', 'g') . '_on_source'
    function! s:{s:on_source}() abort
        autocmd vimrc FileType java setlocal omnifunc=javacomplete#Complete
    endfunction
    call dein#set_hook(g:dein#name, 'hook_source', function('s:' . s:on_source))
endif
" }}}
" elzr/vim-json {{{
if dein#tap('vim-json')
    let s:on_source = substitute(g:dein#name, '\W', '_', 'g') . '_on_source'
    function! s:{s:on_source}() abort
        let g:vim_json_syntax_conceal = 0
    endfunction
    call dein#set_hook(g:dein#name, 'hook_source', function('s:' . s:on_source))
endif
" }}}
" iamcco/markdown-preview.vim' {{{
if dein#tap('markdown-preview.vim')
    let s:on_source = substitute(g:dein#name, '\W', '_', 'g') . '_on_source'
    function! s:{s:on_source}() abort
        let g:mkdp_path_to_chrome = "/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome"
    endfunction
    call dein#set_hook(g:dein#name, 'hook_add', function('s:' . s:on_source))
endif
" }}}
" chrisbra/csv.vim' {{{
if dein#tap('csv.vim')
    let s:on_source = substitute(g:dein#name, '\W', '_', 'g') . '_on_source'
    function! s:{s:on_source}() abort
        let g:csv_delim=','
    endfunction
    call dein#set_hook(g:dein#name, 'hook_add', function('s:' . s:on_source))
endif
" }}}

" functions {{{

command! ReloadVimrc :source $HOME/.vimrc
command! ShowPath :echo expand("%:p")
command! GenerateCtags :!ctags -R

"----------------------------------------
" Denite
"----------------------------------------
"function! DeniteReplace(context)
"      let l:qflist = []
"      for l:target in a:context['targets']
"        if !has_key(l:target, 'action__path') | continue | endif
"        if !has_key(l:target, 'action__line') | continue | endif
"        if !has_key(l:target, 'action__text') | continue | endif
"
"        call add(l:qflist, {
"              \ 'filename': l:target['action__path'],
"              \ 'lnum': l:target['action__line'],
"              \ 'text': l:target['action__text']
"              \ })
"      endfor
"      call setqflist(l:qflist)
"      call qfreplace#start('')
"    endfunction
"call denite#custom#action('file', 'qfreplace', 'DeniteReplace')
"
"function! s:memoGrepDenite()
"    let l:option = '-path=' . expand('$HOME/Dropbox/memolist')
"    exe 'Denite' 'grep' l:option '-highlight-mode-insert=Search'
"endfunction
"command! MemoGrepDenite call s:memoGrepDenite()<CR>

"----------------------------------------
" uncrustify
"----------------------------------------
" see http://stackoverflow.com/questions/12374200/using-uncrustify-with-vim/15513829#15513829

autocmd vimrc FileType cs nnoremap <Leader>f :call UncrustifyAuto()<CR>

" 例: 保存時に自動フォーマット
" autocmd functions BufWritePre <buffer> :call UncrustifyAuto()

" uncrustifyの設定ファイル
let g:uncrustify_cfg_file_path = expand('$DOTDIR/src/uncrustifyconfig')

" uncrustifyでフォーマットする言語
let g:uncrustify_lang = ''
" autocmd FileType c let g:uncrustify_lang = 'c'
" autocmd FileType cpp let g:uncrustify_lang = 'cpp'
" autocmd FileType java let g:uncrustify_lang = 'java'
" autocmd FileType objc let g:uncrustify_lang = 'oc'
autocmd vimrc FileType cs let g:uncrustify_lang = 'cs'

" Restore cursor position, window position, and last search after running a
" command.
function! Preserve(command)
    " Save the last search.
    let l:search = @/
    " Save the current cursor position.
    let l:cursor_position = getpos('.')
    " Save the current window position.
    normal! H
    let l:window_position = getpos('.')
    call setpos('.', l:cursor_position)
    " Execute the command.
    execute a:command
    " Restore the last search.
    let @/ = l:search
    " Restore the previous window position.
    call setpos('.', l:window_position)
    normal! zt
    " Restore the previous cursor position.
    call setpos('.', l:cursor_position)
endfunction

" Don't forget to add Uncrustify executable to $PATH (on Unix) or
" %PATH% (on Windows) for this command to work.
function! Uncrustify(language)
    call Preserve(':silent %!uncrustify'.' -q '.' -l '.a:language.' -c '.
                \shellescape(fnamemodify(g:uncrustify_cfg_file_path, ':p')))
endfunction

function! UncrustifyAuto()
    if g:uncrustify_lang !=# ''
        call Uncrustify(g:uncrustify_lang)
    endif
endfunction

" --------------------------------
" vimからIDE RUN
" --------------------------------
" nnoremap <silent> <Leader>p :call RunIDE()<CR><CR>
" function RunIDE()
"     if (&ft=='cs')
"         :!osascript ~/.dotfiles/AppleScript/runUnity.scpt
"     else
"         :!osascript ~/.dotfiles/AppleScript/runXcode.scpt
"     endif
" endfunction

" }}}

" NOT ACTIVE old plugin setting
" Shougo/denite.nvim {{{
if dein#tap('denite.nvim')
    call denite#custom#source('file_rec', 'matchers', ['matcher_regexp'])
    call denite#custom#map('insert', '<C-n>', '<denite:move_to_next_line>', 'noremap')
    call denite#custom#map('insert', '<C-p>', '<denite:move_to_previous_line>', 'noremap')
    
    call denite#custom#var('file_rec', 'command', ['rg', '--files'])
    call denite#custom#var('grep', 'command', ['rg'])
    
    nmap <silent> <Leader><Leader> :<C-u>Denite file_rec -highlight-mode-insert=Search<CR>
    nmap <silent> <Leader>b :<C-u>Denite buffer -highlight-mode-insert=Search<CR>
    nmap <silent> <Leader>y :<C-u>Denite neoyank -highlight-mode-insert=Search<CR>
    nmap <silent> <Leader>a :<C-u>Denite -resume -highlight-mode-insert=Search<CR>
    nmap <silent> <Leader>gg :<C-u>Denite grep -highlight-mode-insert=Search<CR>
    nmap <silent> <Leader>gc :<C-u>DeniteCursorWord -highlight-mode-insert=Search grep<CR>
    nmap <silent> <Leader>o :<C-u>Denite outline -highlight-mode-insert=Search<CR>
    nmap <silent> <Leader>n :<C-u>Denite -resume -select=+1 -immediately -highlight-mode-insert=Search<CR>
    nmap <silent> <Leader>p :<C-u>Denite -resume -select=-1 -immediately -highlight-mode-insert=Search<CR>
    nmap <Leader>tt :<C-u>Denite -highlight-mode-insert=Search gtags_def:
    nmap <silent> <Leader>tc :<C-u>DeniteCursorWord -highlight-mode-insert=Search gtags_context<CR>
endif
" }}}

set secure
